import fileinput
import os
import re
import shutil
import sys
import time
import traceback
from datetime import date
from importlib import import_module, reload
from pathlib import Path
from types import FunctionType
from typing import TextIO

import click
from aoc.solution import Solution

cwd = os.getcwd()


@click.group()
def cli():
    pass


@cli.command(help="Run a solution for a given day")
@click.argument("day", type=int, required=True)
@click.option("--repeat", is_flag=True)
def run(day: int, repeat: bool = False):
    sys.path.append(cwd)
    try:
        mod = import_module(f"day{day:>02}")
    except ModuleNotFoundError:
        click.echo(
            f"No solution found in current directory, run: aoc init {day}", err=True
        )
        click.get_current_context().exit(1)

    while True:
        solution: Solution = mod.SOLUTION
        start = time.time()

        tests = [
            t
            for t in dir(mod)
            if isinstance(getattr(mod, t), FunctionType) and t.startswith("test_")
        ]
        try:
            click.echo(f"Part 1: {solution.part_1()}")
            click.echo(f"Part 2: {solution.part_2()}\n")

            if tests:
                click.echo("TESTS:")
            for test in tests:
                message = "✅"
                try:
                    getattr(mod, test)()
                except AssertionError as e:
                    _, _, tb = sys.exc_info()
                    tb_info = traceback.extract_tb(tb)
                    _, line, _, text = tb_info[-1]
                    assertion_message = str(e)
                    if not assertion_message:
                        assertion_message = text
                    message = f"❌ {assertion_message}"

                click.echo(f"  {test} ... {message}")
            else:
                click.echo("")

        except Exception as e:
            click.echo("Exception thrown while running solution")
            click.echo(e)

        click.echo(f"Time taken: {time.time() - start:.2}s")

        if not repeat:
            break

        time.sleep(1)
        reload(mod)
        click.clear()


@cli.command(help="Creates a template for a solutions")
@click.argument("day", type=int, required=True)
@click.option("--force", type=bool, is_flag=True)
def init(day: int, force: bool = False):
    click.echo(f"Initialising day {day} in current directory")
    template_path = Path(__file__).parent / "day_n.py"

    solution_path = Path(cwd) / f"day{day:>02}.py"
    data_path = Path(cwd) / f"day{day:>02}.txt"

    if solution_path.exists() and not force:
        click.echo("Solution file already exists, aborting", err=True)
        click.get_current_context().exit(1)

    shutil.copy(template_path, solution_path)
    with fileinput.input(solution_path, inplace=True) as fin:
        for line in fin:
            new_line = line.replace("day=1", f"day={day}")
            print(new_line, end="")

    data_path.touch()


@cli.command(help="Output results into a table")
@click.option("--all", type=bool, is_flag=True)
@click.option(
    "--year",
    type=int,
    help="What year are the solutions for?",
    required=False,
    default=date.today().year,
)
def table(all: bool, year: int):
    sys.path.append(cwd)
    solution_files = [f for f in os.listdir(".") if re.match(r"day\d\d\.py", f)]
    _write_table_to_buffer(sys.stdout, year, 25 if all else len(solution_files))


@cli.command(help="...it creates a readme.")
@click.option(
    "--year",
    type=int,
    help="What year are the solutions for?",
    required=False,
    default=date.today().year,
)
def create_readme(year: int):
    sys.path.append(cwd)
    with open("README.md", "w", encoding="utf-8") as fout:
        fout.write(f"# Advent of Code {year} \n\n")
        fout.write("All files are designed to be ran with my AoC toolbox CLI.\n\n")

        fout.write("```txt\n")
        _write_table_to_buffer(fout, year)
        fout.write("```\n")

        fout.write("\n\n")
        fout.write("_Generated by `aoc create-readme`._\n")
        fout.write("This table renders nicer on the console, honest.\n")


def _format_duration(duration: float) -> str:
    if duration > 0.1:
        return f"{duration:.2f}  s"
    if duration > 0.001:
        return f"{duration * 1_000:.2f} ms"
    if duration > 0.0000001:
        return f"{duration * 100_000:.2f} μs"

    return f"{duration:.2f} s"


def _draw_table(solutions: list[Solution], out: TextIO, year: int):
    max_name_length = 6
    max_part1_length = 10
    max_part2_length = 15
    part_1_header_length = max_part1_length + 5
    part_2_header_length = max_part2_length + 5
    max_time_length = 8
    max_length = (
        max_name_length
        + part_1_header_length
        + part_2_header_length
        + max_time_length
        + 11
    )
    out.write(f"╔{'═' * max_length}╗\n")
    title = f"🐍 Advent of Code {year} 🐍"
    out.write(f"║{title.center(max_length - 2)}║\n")
    out.write(
        "╠{}╦{}╦{}╦{}╣\n".format(
            "═" * (max_name_length + 2),
            "═" * (part_1_header_length + 2),
            "═" * (part_2_header_length + 2),
            "═" * (max_time_length + 2),
        )
    )
    out.write(
        "║{}║{}║{}║{}║\n".format(
            " Day ".center(max_name_length + 2),
            " Part 1 ".center(part_1_header_length + 2),
            " Part 2 ".center(part_2_header_length + 2),
            " Time ".center(max_time_length + 2),
        )
    )
    out.write(
        "╠{}╬{}╦{}╬{}╦{}╬{}╣\n".format(
            "═" * (max_name_length + 2),
            "═" * (max_part1_length + 2),
            "═" * 4,
            "═" * (max_part2_length + 2),
            "═" * 4,
            "═" * (max_time_length + 2),
        )
    )

    total_time = 0

    for solution in solutions:
        start = time.time()
        p1 = solution.part_1()
        p2 = solution.part_2()
        p1_symbol = "✅" if solution.part_1_solved else "❌"
        p2_symbol = "✅" if solution.part_2_solved else "❌"

        duration = time.time() - start
        total_time += duration

        out.write(
            "║ {} ║ {} ║ {} ║ {} ║ {} ║ {} ║\n".format(
                solution.name.ljust(max_name_length),
                str(p1).rjust(max_part1_length),
                p1_symbol,
                str(p2).rjust(max_part2_length),
                p2_symbol,
                _format_duration(duration).rjust(max_time_length),
            )
        )
        out.flush()

    out.write(
        "╚{}╩{}╩{}╩{}╩{}╬{}╣\n".format(
            "═" * (max_name_length + 2),
            "═" * (max_part1_length + 2),
            "═" * 4,
            "═" * (max_part2_length + 2),
            "═" * 4,
            "═" * (max_time_length + 2),
        )
    )
    out.write(
        " {} {} {} {} {}║ {} ║\n".format(
            " " * (max_name_length + 2),
            " " * (max_part1_length + 2),
            " " * 4,
            " " * (max_part2_length + 2),
            " " * 4,
            _format_duration(total_time).rjust(max_time_length),
        )
    )
    out.write(
        " {} {} {} {} {}╚{}╝\n".format(
            " " * (max_name_length + 2),
            " " * (max_part1_length + 2),
            " " * 4,
            " " * (max_part2_length + 2),
            " " * 4,
            "═" * (max_time_length + 2),
        )
    )


def _write_table_to_buffer(out: TextIO, year: int, num_days: int = 25):
    solutions = []

    for day in range(1, num_days + 1):
        try:
            daily_mod = __import__(f"day{day:>02}")
            solutions.append(daily_mod.SOLUTION)
        except (ImportError, AttributeError):
            solutions.append(
                Solution(
                    day=day,
                    part_1_answer=0,
                    part_1=lambda _: -1,
                    part_2_answer=0,
                    part_2=lambda _: -1,
                    parse_data=lambda _: _,
                )
            )

    _draw_table(solutions, out, year)
